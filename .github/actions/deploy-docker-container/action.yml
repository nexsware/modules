name: 'Deploy Docker Container'
description: 'Deploys a Docker container to a server via SSH'
inputs:
  server-ip:
    description: 'Server IP address'
    required: true
  ssh-private-key:
    description: 'SSH private key for server access'
    required: true
  ssh-user:
    description: 'SSH user for server access'
    required: false
    default: 'root'
  container-name:
    description: 'Name for the container'
    required: true
  image-name:
    description: 'Full Docker image name with tag'
    required: true
  container-port:
    description: 'Internal container port'
    required: false
    default: '80'
  host-port:
    description: 'Host port to expose container on'
    required: false
    default: '3000'
  registry:
    description: 'Container registry URL'
    required: false
    default: 'ghcr.io'
  registry-username:
    description: 'Registry username for pulling images'
    required: false
  registry-token:
    description: 'Registry token/password for pulling images'
    required: false
  env-vars:
    description: 'Environment variables for container (one per line, format: KEY=value)'
    required: false
    default: ''
  network-mode:
    description: 'Docker network mode'
    required: false
    default: 'bridge'
  restart-policy:
    description: 'Container restart policy'
    required: false
    default: 'unless-stopped'
  additional-docker-args:
    description: 'Additional docker run arguments'
    required: false
    default: ''

outputs:
  deploy-status:
    description: 'Deployment status'
    value: ${{ steps.deploy.outputs.status }}
  container-id:
    description: 'Deployed container ID'
    value: ${{ steps.deploy.outputs.container_id }}

runs:
  using: 'composite'
  steps:
    - name: Setup SSH Key
      shell: bash
      run: |
        mkdir -p ~/.ssh
        printf '%s\n' '${{ inputs.ssh-private-key }}' > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        ssh-keyscan -H ${{ inputs.server-ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

    - name: Install Docker on Server
      shell: bash
      run: |
        ssh -i ~/.ssh/deploy_key ${{ inputs.ssh-user }}@${{ inputs.server-ip }} << 'ENDSSH'
        set -e

        # Check if Docker is installed
        if ! command -v docker &> /dev/null; then
          echo "Installing Docker..."
          curl -fsSL https://get.docker.com -o get-docker.sh
          sh get-docker.sh
          systemctl enable docker
          systemctl start docker
          rm get-docker.sh
        else
          echo "Docker is already installed"
        fi

        docker --version
        ENDSSH

    - name: Check and Fix Nginx Configuration
      shell: bash
      run: |
        ssh -i ~/.ssh/deploy_key ${{ inputs.ssh-user }}@${{ inputs.server-ip }} << 'ENDSSH'
        set -e

        echo "Checking nginx status..."

        # Check if nginx is installed
        if ! command -v nginx &> /dev/null; then
          echo "Nginx is not installed, skipping nginx check"
          exit 0
        fi

        # Check if nginx is running and config is valid
        if ! systemctl is-active --quiet nginx || ! nginx -t 2>/dev/null; then
          echo "Nginx is broken or config is invalid. Attempting to fix..."

          # Find all domain configs that reference missing SSL certificates
          for conf in /etc/nginx/sites-enabled/*; do
            if [ -f "$conf" ]; then
              # Check if config references letsencrypt certs that don't exist
              if grep -q "/etc/letsencrypt/" "$conf"; then
                DOMAIN=$(basename "$conf")
                echo "Fixing nginx config for $DOMAIN (removing SSL references)..."

                # Create HTTP-only config
                cat > "$conf" << 'EOF'
server {
    listen 80;
    server_name _;

    location / {
        proxy_pass http://localhost:${{ inputs.host-port }};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
EOF
              fi
            fi
          done

          # Test and restart nginx
          if nginx -t; then
            systemctl restart nginx
            echo "Nginx fixed and restarted successfully"
          else
            echo "Failed to fix nginx configuration"
            exit 1
          fi
        else
          echo "Nginx is running correctly"
        fi
        ENDSSH

    - name: Deploy Container
      id: deploy
      shell: bash
      run: |
        OUTPUT=$(ssh -i ~/.ssh/deploy_key ${{ inputs.ssh-user }}@${{ inputs.server-ip }} << 'ENDSSH'
        set -e

        # Extract first line of image name (in case multiple tags were passed)
        IMAGE_NAME=$(echo "${{ inputs.image-name }}" | head -n 1)
        echo "Resolved image name: $IMAGE_NAME"

        # Login to container registry if credentials provided
        if [ -n "${{ inputs.registry-token }}" ]; then
          echo "${{ inputs.registry-token }}" | docker login ${{ inputs.registry }} \
            -u "${{ inputs.registry-username }}" --password-stdin
        fi

        # Pull the latest image
        echo "Pulling image: $IMAGE_NAME"
        docker pull "$IMAGE_NAME"

        # Stop and remove existing container if it exists
        if [ "$(docker ps -aq -f name=${{ inputs.container-name }})" ]; then
          echo "Stopping existing container: ${{ inputs.container-name }}"
          docker stop ${{ inputs.container-name }} || true
          docker rm ${{ inputs.container-name }} || true
        fi

        # Parse environment variables
        ENV_ARGS=""
        if [ -n "${{ inputs.env-vars }}" ]; then
          while IFS= read -r line; do
            if [ -n "$line" ]; then
              ENV_ARGS="$ENV_ARGS -e $line"
            fi
          done <<< "${{ inputs.env-vars }}"
        fi

        # Run the new container
        echo "Starting container: ${{ inputs.container-name }}"
        CONTAINER_ID=$(docker run -d \
          --name ${{ inputs.container-name }} \
          --restart ${{ inputs.restart-policy }} \
          --network ${{ inputs.network-mode }} \
          -p ${{ inputs.host-port }}:${{ inputs.container-port }} \
          $ENV_ARGS \
          ${{ inputs.additional-docker-args }} \
          "$IMAGE_NAME")

        echo "Container ID: $CONTAINER_ID"

        # Wait for container to be healthy
        sleep 5

        # Check container status
        if docker ps | grep -q ${{ inputs.container-name }}; then
          echo "Container is running successfully"
          echo "DEPLOY_STATUS=success"
          echo "CONTAINER_ID=$CONTAINER_ID"
        else
          echo "Container failed to start"
          docker logs ${{ inputs.container-name }}
          exit 1
        fi

        # Show container info
        docker ps -f name=${{ inputs.container-name }}

        ENDSSH
        )

        echo "$OUTPUT"

        # Extract outputs from SSH session and write to GITHUB_OUTPUT
        DEPLOY_STATUS=$(echo "$OUTPUT" | grep "DEPLOY_STATUS=" | cut -d'=' -f2)
        CONTAINER_ID=$(echo "$OUTPUT" | grep "CONTAINER_ID=" | cut -d'=' -f2)

        echo "status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT
        echo "container_id=$CONTAINER_ID" >> $GITHUB_OUTPUT

    - name: Cleanup SSH Key
      if: always()
      shell: bash
      run: |
        rm -f ~/.ssh/deploy_key
