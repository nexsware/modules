name: Deploy Database Instance (Reusable)

on:
  workflow_call:
    inputs:
      region:
        description: 'Linode Region'
        required: true
        type: string
      instance_type:
        description: 'Linode Instance Type'
        required: true
        type: string
      image:
        description: 'Linode Image'
        required: true
        type: string
      environment:
        description: 'Deployment environment (e.g., test, prod)'
        required: true
        type: string
      instance_label:
        description: 'Instance label (e.g., prod-database)'
        required: true
        type: string
      vpc_id:
        description: 'Linode VPC ID to attach the instance to'
        required: true
        type: string
      subnet_id:
        description: 'Linode Subnet ID to attach the instance to'
        required: true
        type: string
      # PostgreSQL Configuration
      postgres_version:
        description: 'PostgreSQL version (e.g., 16, 15, 14)'
        required: false
        type: string
        default: '16'
      postgres_db:
        description: 'Default database name to create'
        required: false
        type: string
        default: 'appdb'
      postgres_user:
        description: 'PostgreSQL username'
        required: false
        type: string
        default: 'postgres'
      # Firewall Configuration
      enable_firewall:
        description: 'Whether to create and attach a firewall'
        required: false
        type: boolean
        default: true
      vpc_subnet_cidr:
        description: 'VPC subnet CIDR to allow PostgreSQL access from (e.g., 10.0.0.0/27)'
        required: false
        type: string
        default: '10.0.0.0/27'
      admin_ssh_ip:
        description: 'Your IP address for SSH access (CIDR notation, e.g., 1.2.3.4/32). Leave empty to allow from anywhere.'
        required: false
        type: string
        default: ''
    secrets:
      LINODE_TOKEN:
        description: 'Linode API Token'
        required: true
      ROOT_PASS:
        description: 'Root Password for Linode Instance'
        required: true
      SSH_PUBLIC_KEY:
        description: 'SSH Public Key for Linode Instance'
        required: false
      SSH_PRIVATE_KEY:
        description: 'SSH Private Key for server access'
        required: true
      POSTGRES_PASSWORD:
        description: 'PostgreSQL password'
        required: true
    outputs:
      instance_id:
        description: 'The ID of the created instance'
        value: ${{ jobs.deploy-instance.outputs.instance_id }}
      public_ip:
        description: 'The public IP address of the instance (for SSH access only)'
        value: ${{ jobs.deploy-instance.outputs.public_ip }}
      vpc_ip:
        description: 'The VPC private IP address of the instance'
        value: ${{ jobs.deploy-postgres.outputs.vpc_ip }}
      postgres_host:
        description: 'PostgreSQL host (VPC IP - for app connections)'
        value: ${{ jobs.deploy-postgres.outputs.postgres_host }}
      postgres_port:
        description: 'PostgreSQL port'
        value: ${{ jobs.deploy-postgres.outputs.postgres_port }}
      postgres_connection_string:
        description: 'PostgreSQL connection string for applications'
        value: ${{ jobs.deploy-postgres.outputs.postgres_connection_string }}
      ssh_tunnel_command:
        description: 'SSH tunnel command for local pgAdmin access'
        value: ${{ jobs.deploy-postgres.outputs.ssh_tunnel_command }}

jobs:
  deploy-instance:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      instance_id: ${{ steps.create-instance.outputs.instance_id }}
      public_ip: ${{ steps.create-instance.outputs.public_ip }}
    steps:
      - name: Create Database Instance
        id: create-instance
        run: |
          echo "Creating Linode instance for database..."

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "type": "${{ inputs.instance_type }}",
              "region": "${{ inputs.region }}",
              "image": "${{ inputs.image }}",
              "label": "${{ inputs.instance_label }}",
              "root_pass": "${{ secrets.ROOT_PASS }}",
              "authorized_keys": ["${{ secrets.SSH_PUBLIC_KEY }}"],
              "tags": ["${{ inputs.environment }}", "database"],
              "private_ip": true,
              "interfaces": [
                {
                  "purpose": "public"
                },
                {
                  "purpose": "vpc",
                  "subnet_id": ${{ inputs.subnet_id }}
                }
              ]
            }' \
            "https://api.linode.com/v4/linode/instances")

          INSTANCE_ID=$(echo "$RESPONSE" | jq -r '.id')
          PUBLIC_IP=$(echo "$RESPONSE" | jq -r '.ipv4[0]')

          if [ "$INSTANCE_ID" == "null" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Failed to create instance"
            echo "$RESPONSE" | jq .
            exit 1
          fi

          echo "Instance created successfully!"
          echo "Instance ID: $INSTANCE_ID"
          echo "Public IP: $PUBLIC_IP"

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Wait for Instance to Boot
        run: |
          echo "Waiting for instance to boot..."
          PUBLIC_IP="${{ steps.create-instance.outputs.public_ip }}"

          for i in {1..60}; do
            STATUS=$(curl -s -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
              "https://api.linode.com/v4/linode/instances/${{ steps.create-instance.outputs.instance_id }}" | \
              jq -r '.status')

            echo "Instance status: $STATUS (attempt $i/60)"

            if [ "$STATUS" == "running" ]; then
              echo "Instance is running!"
              break
            fi
            sleep 10
          done

          # Wait for SSH to be available
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if timeout 5 bash -c "cat < /dev/null > /dev/tcp/$PUBLIC_IP/22" 2>/dev/null; then
              echo "SSH is available!"
              sleep 10
              break
            fi
            echo "Waiting for SSH... (attempt $i/30)"
            sleep 10
          done

  configure-firewall:
    runs-on: ubuntu-latest
    needs: deploy-instance
    if: ${{ inputs.enable_firewall }}
    environment: ${{ inputs.environment }}
    steps:
      - name: Create Database Firewall
        id: create-firewall
        run: |
          echo "Creating firewall for database instance..."

          # Prepare SSH inbound rule
          if [ -n "${{ inputs.admin_ssh_ip }}" ]; then
            SSH_IPV4='["${{ inputs.admin_ssh_ip }}"]'
            SSH_IPV6='[]'
          else
            SSH_IPV4='["0.0.0.0/0"]'
            SSH_IPV6='["::/0"]'
          fi

          echo "Debug - SSH_IPV4: $SSH_IPV4"
          echo "Debug - SSH_IPV6: $SSH_IPV6"

          # Create firewall with rules
          FIREWALL_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"label\": \"${{ inputs.instance_label }}-firewall\",
              \"tags\": [\"${{ inputs.environment }}\", \"database\"],
              \"rules\": {
                \"inbound\": [
                  {
                    \"label\": \"allow-ssh\",
                    \"action\": \"ACCEPT\",
                    \"protocol\": \"TCP\",
                    \"ports\": \"22\",
                    \"addresses\": {
                      \"ipv4\": $SSH_IPV4,
                      \"ipv6\": $SSH_IPV6
                    }
                  },
                  {
                    \"label\": \"allow-postgres-from-vpc\",
                    \"action\": \"ACCEPT\",
                    \"protocol\": \"TCP\",
                    \"ports\": \"5432\",
                    \"addresses\": {
                      \"ipv4\": [\"${{ inputs.vpc_subnet_cidr }}\"]
                    }
                  }
                ],
                \"inbound_policy\": \"DROP\",
                \"outbound\": [
                  {
                    \"label\": \"allow-all-outbound\",
                    \"action\": \"ACCEPT\",
                    \"protocol\": \"TCP\",
                    \"ports\": \"1-65535\",
                    \"addresses\": {
                      \"ipv4\": [\"0.0.0.0/0\"],
                      \"ipv6\": [\"::/0\"]
                    }
                  },
                  {
                    \"label\": \"allow-all-outbound-udp\",
                    \"action\": \"ACCEPT\",
                    \"protocol\": \"UDP\",
                    \"ports\": \"1-65535\",
                    \"addresses\": {
                      \"ipv4\": [\"0.0.0.0/0\"],
                      \"ipv6\": [\"::/0\"]
                    }
                  }
                ],
                \"outbound_policy\": \"ACCEPT\"
              }
            }" \
            "https://api.linode.com/v4/networking/firewalls")

          FIREWALL_ID=$(echo "$FIREWALL_RESPONSE" | jq -r '.id')

          if [ "$FIREWALL_ID" == "null" ] || [ -z "$FIREWALL_ID" ]; then
            echo "Failed to create firewall"
            echo "$FIREWALL_RESPONSE" | jq .
            exit 1
          fi

          echo "Firewall created successfully!"
          echo "Firewall ID: $FIREWALL_ID"

          # Attach firewall to instance
          echo "Attaching firewall to instance..."
          ATTACH_RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{
              \"id\": ${{ needs.deploy-instance.outputs.instance_id }},
              \"type\": \"linode\"
            }" \
            "https://api.linode.com/v4/networking/firewalls/${FIREWALL_ID}/devices")

          echo "Firewall attached to instance"
          echo "Firewall Rules:"
          echo "  - SSH (22): ${{ inputs.admin_ssh_ip != '' && inputs.admin_ssh_ip || 'Allowed from anywhere' }}"
          echo "  - PostgreSQL (5432): Only from VPC subnet ${{ inputs.vpc_subnet_cidr }}"
          echo "  - All other inbound traffic: BLOCKED"

  harden-ssh:
    runs-on: ubuntu-latest
    needs: deploy-instance
    environment: ${{ inputs.environment }}
    steps:
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' '${{ secrets.SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ needs.deploy-instance.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Harden SSH Configuration
        run: |
          PUBLIC_IP="${{ needs.deploy-instance.outputs.public_ip }}"

          ssh -i ~/.ssh/deploy_key root@${PUBLIC_IP} << 'ENDSSH'
          set -e

          echo "Hardening SSH configuration..."

          # Backup original sshd_config
          cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup

          # Disable password authentication
          sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
          sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config

          # Disable root password login (keep key-based root login)
          sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config
          sed -i 's/PermitRootLogin yes/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config

          # Disable empty passwords
          sed -i 's/#PermitEmptyPasswords no/PermitEmptyPasswords no/' /etc/ssh/sshd_config
          sed -i 's/PermitEmptyPasswords yes/PermitEmptyPasswords no/' /etc/ssh/sshd_config

          # Enable public key authentication (should already be enabled)
          sed -i 's/#PubkeyAuthentication yes/PubkeyAuthentication yes/' /etc/ssh/sshd_config

          # Test configuration
          echo "Testing SSH configuration..."
          sshd -t

          if [ $? -eq 0 ]; then
            echo "SSH configuration is valid"
            # Ubuntu uses 'ssh' service name, not 'sshd'
            systemctl restart ssh
            echo "✓ SSH hardened successfully"
            echo "  - Password authentication: DISABLED"
            echo "  - Root login: Key-based only"
            echo "  - Public key authentication: ENABLED"
          else
            echo "✗ SSH configuration test failed, restoring backup"
            cp /etc/ssh/sshd_config.backup /etc/ssh/sshd_config
            exit 1
          fi
          ENDSSH

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key

  deploy-postgres:
    runs-on: ubuntu-latest
    needs: deploy-instance
    environment: ${{ inputs.environment }}
    outputs:
      vpc_ip: ${{ steps.get-vpc-ip.outputs.vpc_ip }}
      postgres_host: ${{ steps.deploy-db.outputs.postgres_host }}
      postgres_port: ${{ steps.deploy-db.outputs.postgres_port }}
      postgres_connection_string: ${{ steps.deploy-db.outputs.connection_string }}
      ssh_tunnel_command: ${{ steps.deploy-db.outputs.ssh_tunnel_command }}
    steps:
      - name: Get Instance VPC IP
        id: get-vpc-ip
        run: |
          echo "Fetching VPC IP for instance..."

          # VPC IP may not be immediately available, retry for up to 2 minutes
          for i in {1..24}; do
            INSTANCE_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
              "https://api.linode.com/v4/linode/instances/${{ needs.deploy-instance.outputs.instance_id }}")

            # VPC IPs can be in 10.x.x.x or 192.168.x.x ranges
            VPC_IP=$(echo "$INSTANCE_DATA" | jq -r '.ipv4[] | select(startswith("10.") or startswith("192.168."))')

            if [ -n "$VPC_IP" ]; then
              echo "VPC IP found: $VPC_IP"
              echo "vpc_ip=$VPC_IP" >> $GITHUB_OUTPUT
              exit 0
            fi

            echo "VPC IP not yet assigned (attempt $i/24), waiting 5 seconds..."
            sleep 5
          done

          echo "Error: No VPC IP found for instance after 2 minutes"
          echo "Instance data:"
          echo "$INSTANCE_DATA" | jq .
          exit 1

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' '${{ secrets.SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ needs.deploy-instance.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Install Docker and Deploy PostgreSQL
        id: deploy-db
        run: |
          VPC_IP="${{ steps.get-vpc-ip.outputs.vpc_ip }}"
          PUBLIC_IP="${{ needs.deploy-instance.outputs.public_ip }}"

          ssh -i ~/.ssh/deploy_key root@${PUBLIC_IP} << 'ENDSSH'
          set -e

          echo "Installing Docker..."
          if ! command -v docker &> /dev/null; then
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            systemctl enable docker
            systemctl start docker
            rm get-docker.sh
          fi

          echo "Docker installed successfully"
          docker --version

          # Get VPC IP
          VPC_IP=$(ip -4 addr show | grep -oP '10\.\d+\.\d+\.\d+' | head -1)
          echo "Binding PostgreSQL to VPC IP: $VPC_IP"

          # Create volume for data persistence
          if ! docker volume inspect postgres-data >/dev/null 2>&1; then
            echo "Creating data volume: postgres-data"
            docker volume create postgres-data
          fi

          # Stop and remove existing container if it exists
          if [ "$(docker ps -aq -f name=postgres)" ]; then
            echo "Stopping existing PostgreSQL container..."
            docker stop postgres || true
            docker rm postgres || true
          fi

          # Deploy PostgreSQL container bound to VPC IP
          echo "Deploying PostgreSQL ${{ inputs.postgres_version }} container..."
          docker run -d \
            --name postgres \
            --restart unless-stopped \
            -e POSTGRES_USER=${{ inputs.postgres_user }} \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ inputs.postgres_db }} \
            -v postgres-data:/var/lib/postgresql/data \
            -p ${VPC_IP}:5432:5432 \
            postgres:${{ inputs.postgres_version }}

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          sleep 15

          # Check container status
          if docker ps | grep -q postgres; then
            echo "✓ PostgreSQL container is running successfully"
            docker logs postgres --tail 30
          else
            echo "✗ PostgreSQL container failed to start"
            docker logs postgres
            exit 1
          fi

          # Test connection
          echo "Testing PostgreSQL connection..."
          docker exec postgres pg_isready -U ${{ inputs.postgres_user }}

          echo "POSTGRES_DEPLOYED=success"
          ENDSSH

          # Set outputs
          POSTGRES_HOST="${{ steps.get-vpc-ip.outputs.vpc_ip }}"

          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "postgres_port=5432" >> $GITHUB_OUTPUT

          # Connection string for applications (other servers in VPC)
          CONN_STRING="postgresql://${{ inputs.postgres_user }}:${{ secrets.POSTGRES_PASSWORD }}@${POSTGRES_HOST}:5432/${{ inputs.postgres_db }}"
          echo "connection_string=$CONN_STRING" >> $GITHUB_OUTPUT

          # SSH tunnel command for local pgAdmin access
          TUNNEL_CMD="ssh -L 5432:${POSTGRES_HOST}:5432 root@${PUBLIC_IP}"
          echo "ssh_tunnel_command=$TUNNEL_CMD" >> $GITHUB_OUTPUT

      - name: Display Connection Info
        run: |
          echo "========================================="
          echo "Database Instance Deployed Successfully!"
          echo "========================================="
          echo ""
          echo "Instance Details:"
          echo "  Instance ID: ${{ needs.deploy-instance.outputs.instance_id }}"
          echo "  Public IP: ${{ needs.deploy-instance.outputs.public_ip }} (SSH access only)"
          echo "  VPC IP: ${{ steps.get-vpc-ip.outputs.vpc_ip }}"
          echo ""
          echo "PostgreSQL Connection (from app servers in VPC):"
          echo "  Host: ${{ steps.deploy-db.outputs.postgres_host }}"
          echo "  Port: ${{ steps.deploy-db.outputs.postgres_port }}"
          echo "  User: ${{ inputs.postgres_user }}"
          echo "  Database: ${{ inputs.postgres_db }}"
          echo "  Connection String: ${{ steps.deploy-db.outputs.connection_string }}"
          echo ""
          echo "Security:"
          echo "  - PostgreSQL is bound to VPC IP only"
          echo "  - NOT accessible from public internet"
          echo "  - Only accessible from servers in the same VPC subnet"
          echo ""
          echo "For local pgAdmin access, create SSH tunnel:"
          echo "  ${{ steps.deploy-db.outputs.ssh_tunnel_command }}"
          echo ""
          echo "Then connect pgAdmin to:"
          echo "  Host: localhost"
          echo "  Port: 5432"
          echo "  User: ${{ inputs.postgres_user }}"
          echo "  Database: ${{ inputs.postgres_db }}"
          echo "========================================="

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
