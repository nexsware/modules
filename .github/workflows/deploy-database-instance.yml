name: Deploy Database Instance (Reusable)

on:
  workflow_call:
    inputs:
      region:
        description: 'Linode Region'
        required: true
        type: string
      instance_type:
        description: 'Linode Instance Type'
        required: true
        type: string
      image:
        description: 'Linode Image'
        required: true
        type: string
      environment:
        description: 'Deployment environment (e.g., test, prod)'
        required: true
        type: string
      instance_label:
        description: 'Instance label (e.g., prod-database)'
        required: true
        type: string
      vpc_id:
        description: 'Linode VPC ID to attach the instance to'
        required: true
        type: string
      subnet_id:
        description: 'Linode Subnet ID to attach the instance to'
        required: true
        type: string
      # PostgreSQL Configuration
      postgres_version:
        description: 'PostgreSQL version (e.g., 16, 15, 14)'
        required: false
        type: string
        default: '16'
      postgres_db:
        description: 'Default database name to create'
        required: false
        type: string
        default: 'appdb'
      postgres_user:
        description: 'PostgreSQL username'
        required: false
        type: string
        default: 'postgres'
    secrets:
      LINODE_TOKEN:
        description: 'Linode API Token'
        required: true
      ROOT_PASS:
        description: 'Root Password for Linode Instance'
        required: true
      SSH_PUBLIC_KEY:
        description: 'SSH Public Key for Linode Instance'
        required: false
      SSH_PRIVATE_KEY:
        description: 'SSH Private Key for server access'
        required: true
      POSTGRES_PASSWORD:
        description: 'PostgreSQL password'
        required: true
    outputs:
      instance_id:
        description: 'The ID of the created instance'
        value: ${{ jobs.deploy-instance.outputs.instance_id }}
      public_ip:
        description: 'The public IP address of the instance (for SSH access only)'
        value: ${{ jobs.deploy-instance.outputs.public_ip }}
      vpc_ip:
        description: 'The VPC private IP address of the instance'
        value: ${{ jobs.deploy-postgres.outputs.vpc_ip }}
      postgres_host:
        description: 'PostgreSQL host (VPC IP - for app connections)'
        value: ${{ jobs.deploy-postgres.outputs.postgres_host }}
      postgres_port:
        description: 'PostgreSQL port'
        value: ${{ jobs.deploy-postgres.outputs.postgres_port }}
      postgres_connection_string:
        description: 'PostgreSQL connection string for applications'
        value: ${{ jobs.deploy-postgres.outputs.postgres_connection_string }}
      ssh_tunnel_command:
        description: 'SSH tunnel command for local pgAdmin access'
        value: ${{ jobs.deploy-postgres.outputs.ssh_tunnel_command }}

jobs:
  deploy-instance:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    outputs:
      instance_id: ${{ steps.create-instance.outputs.instance_id }}
      public_ip: ${{ steps.create-instance.outputs.public_ip }}
    steps:
      - name: Create Database Instance
        id: create-instance
        run: |
          echo "Creating Linode instance for database..."

          RESPONSE=$(curl -s -X POST \
            -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "type": "${{ inputs.instance_type }}",
              "region": "${{ inputs.region }}",
              "image": "${{ inputs.image }}",
              "label": "${{ inputs.instance_label }}",
              "root_pass": "${{ secrets.ROOT_PASS }}",
              "authorized_keys": ["${{ secrets.SSH_PUBLIC_KEY }}"],
              "tags": ["${{ inputs.environment }}", "database"],
              "private_ip": true,
              "interfaces": [
                {
                  "purpose": "public"
                },
                {
                  "purpose": "vpc",
                  "subnet_id": ${{ inputs.subnet_id }}
                }
              ]
            }' \
            "https://api.linode.com/v4/linode/instances")

          INSTANCE_ID=$(echo "$RESPONSE" | jq -r '.id')
          PUBLIC_IP=$(echo "$RESPONSE" | jq -r '.ipv4[0]')

          if [ "$INSTANCE_ID" == "null" ] || [ -z "$INSTANCE_ID" ]; then
            echo "Failed to create instance"
            echo "$RESPONSE" | jq .
            exit 1
          fi

          echo "Instance created successfully!"
          echo "Instance ID: $INSTANCE_ID"
          echo "Public IP: $PUBLIC_IP"

          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Wait for Instance to Boot
        run: |
          echo "Waiting for instance to boot..."
          PUBLIC_IP="${{ steps.create-instance.outputs.public_ip }}"

          for i in {1..60}; do
            STATUS=$(curl -s -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
              "https://api.linode.com/v4/linode/instances/${{ steps.create-instance.outputs.instance_id }}" | \
              jq -r '.status')

            echo "Instance status: $STATUS (attempt $i/60)"

            if [ "$STATUS" == "running" ]; then
              echo "Instance is running!"
              break
            fi
            sleep 10
          done

          # Wait for SSH to be available
          echo "Waiting for SSH to be available..."
          for i in {1..30}; do
            if timeout 5 bash -c "cat < /dev/null > /dev/tcp/$PUBLIC_IP/22" 2>/dev/null; then
              echo "SSH is available!"
              sleep 10
              break
            fi
            echo "Waiting for SSH... (attempt $i/30)"
            sleep 10
          done

  deploy-postgres:
    runs-on: ubuntu-latest
    needs: deploy-instance
    environment: ${{ inputs.environment }}
    outputs:
      vpc_ip: ${{ steps.get-vpc-ip.outputs.vpc_ip }}
      postgres_host: ${{ steps.deploy-db.outputs.postgres_host }}
      postgres_port: ${{ steps.deploy-db.outputs.postgres_port }}
      postgres_connection_string: ${{ steps.deploy-db.outputs.connection_string }}
      ssh_tunnel_command: ${{ steps.deploy-db.outputs.ssh_tunnel_command }}
    steps:
      - name: Get Instance VPC IP
        id: get-vpc-ip
        run: |
          echo "Fetching VPC IP for instance..."
          INSTANCE_DATA=$(curl -s -H "Authorization: Bearer ${{ secrets.LINODE_TOKEN }}" \
            "https://api.linode.com/v4/linode/instances/${{ needs.deploy-instance.outputs.instance_id }}")

          VPC_IP=$(echo "$INSTANCE_DATA" | jq -r '.ipv4[] | select(startswith("10."))')

          if [ -z "$VPC_IP" ]; then
            echo "Error: No VPC IP found for instance"
            exit 1
          fi

          echo "VPC IP: $VPC_IP"
          echo "vpc_ip=$VPC_IP" >> $GITHUB_OUTPUT

      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' '${{ secrets.SSH_PRIVATE_KEY }}' > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ needs.deploy-instance.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Install Docker and Deploy PostgreSQL
        id: deploy-db
        run: |
          VPC_IP="${{ steps.get-vpc-ip.outputs.vpc_ip }}"
          PUBLIC_IP="${{ needs.deploy-instance.outputs.public_ip }}"

          ssh -i ~/.ssh/deploy_key root@${PUBLIC_IP} << 'ENDSSH'
          set -e

          echo "Installing Docker..."
          if ! command -v docker &> /dev/null; then
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh
            systemctl enable docker
            systemctl start docker
            rm get-docker.sh
          fi

          echo "Docker installed successfully"
          docker --version

          # Get VPC IP
          VPC_IP=$(ip -4 addr show | grep -oP '10\.\d+\.\d+\.\d+' | head -1)
          echo "Binding PostgreSQL to VPC IP: $VPC_IP"

          # Create volume for data persistence
          if ! docker volume inspect postgres-data >/dev/null 2>&1; then
            echo "Creating data volume: postgres-data"
            docker volume create postgres-data
          fi

          # Stop and remove existing container if it exists
          if [ "$(docker ps -aq -f name=postgres)" ]; then
            echo "Stopping existing PostgreSQL container..."
            docker stop postgres || true
            docker rm postgres || true
          fi

          # Deploy PostgreSQL container bound to VPC IP
          echo "Deploying PostgreSQL ${{ inputs.postgres_version }} container..."
          docker run -d \
            --name postgres \
            --restart unless-stopped \
            -e POSTGRES_USER=${{ inputs.postgres_user }} \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ inputs.postgres_db }} \
            -v postgres-data:/var/lib/postgresql/data \
            -p ${VPC_IP}:5432:5432 \
            postgres:${{ inputs.postgres_version }}

          # Wait for PostgreSQL to be ready
          echo "Waiting for PostgreSQL to be ready..."
          sleep 15

          # Check container status
          if docker ps | grep -q postgres; then
            echo "✓ PostgreSQL container is running successfully"
            docker logs postgres --tail 30
          else
            echo "✗ PostgreSQL container failed to start"
            docker logs postgres
            exit 1
          fi

          # Test connection
          echo "Testing PostgreSQL connection..."
          docker exec postgres pg_isready -U ${{ inputs.postgres_user }}

          echo "POSTGRES_DEPLOYED=success"
          ENDSSH

          # Set outputs
          POSTGRES_HOST="${{ steps.get-vpc-ip.outputs.vpc_ip }}"

          echo "postgres_host=$POSTGRES_HOST" >> $GITHUB_OUTPUT
          echo "postgres_port=5432" >> $GITHUB_OUTPUT

          # Connection string for applications (other servers in VPC)
          CONN_STRING="postgresql://${{ inputs.postgres_user }}:${{ secrets.POSTGRES_PASSWORD }}@${POSTGRES_HOST}:5432/${{ inputs.postgres_db }}"
          echo "connection_string=$CONN_STRING" >> $GITHUB_OUTPUT

          # SSH tunnel command for local pgAdmin access
          TUNNEL_CMD="ssh -L 5432:${POSTGRES_HOST}:5432 root@${PUBLIC_IP}"
          echo "ssh_tunnel_command=$TUNNEL_CMD" >> $GITHUB_OUTPUT

      - name: Display Connection Info
        run: |
          echo "========================================="
          echo "Database Instance Deployed Successfully!"
          echo "========================================="
          echo ""
          echo "Instance Details:"
          echo "  Instance ID: ${{ needs.deploy-instance.outputs.instance_id }}"
          echo "  Public IP: ${{ needs.deploy-instance.outputs.public_ip }} (SSH access only)"
          echo "  VPC IP: ${{ steps.get-vpc-ip.outputs.vpc_ip }}"
          echo ""
          echo "PostgreSQL Connection (from app servers in VPC):"
          echo "  Host: ${{ steps.deploy-db.outputs.postgres_host }}"
          echo "  Port: ${{ steps.deploy-db.outputs.postgres_port }}"
          echo "  User: ${{ inputs.postgres_user }}"
          echo "  Database: ${{ inputs.postgres_db }}"
          echo "  Connection String: ${{ steps.deploy-db.outputs.connection_string }}"
          echo ""
          echo "Security:"
          echo "  - PostgreSQL is bound to VPC IP only"
          echo "  - NOT accessible from public internet"
          echo "  - Only accessible from servers in the same VPC subnet"
          echo ""
          echo "For local pgAdmin access, create SSH tunnel:"
          echo "  ${{ steps.deploy-db.outputs.ssh_tunnel_command }}"
          echo ""
          echo "Then connect pgAdmin to:"
          echo "  Host: localhost"
          echo "  Port: 5432"
          echo "  User: ${{ inputs.postgres_user }}"
          echo "  Database: ${{ inputs.postgres_db }}"
          echo "========================================="

      - name: Cleanup SSH Key
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
