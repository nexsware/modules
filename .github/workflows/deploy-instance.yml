name: Deploy Linode Instance (Reusable)

on:
  workflow_call:
    inputs:
      region:
        description: 'Linode Region'
        required: true
        type: string
      instance_type:
        description: 'Linode Instance Type'
        required: true
        type: string
      image:
        description: 'Linode Image'
        required: true
        type: string
      environment:
        description: 'Deployment environment (e.g., test, prod)'
        required: true
        type: string
      application_name:
        description: 'Application Name'
        required: false
        type: string
        default: ''
      terraform_dir:
        description: 'Directory containing Terraform configuration'
        required: false
        type: string
        default: 'modules/terraform/linode/instance'
    secrets:
      LINODE_TOKEN:
        description: 'Linode API Token'
        required: false
      ROOT_PASS:
        description: 'Root Password for Linode Instance'
        required: false
      SSH_PUBLIC_KEY:
        description: 'SSH Public Keys for Linode Instance'
        required: false
    outputs:
      instance_id:
        description: 'The ID of the created instance'
        value: ${{ jobs.deploy-instance.outputs.instance_id }}
      ip_address:
        description: 'The IP address of the created instance'
        value: ${{ jobs.deploy-instance.outputs.ip_address }}

jobs:
  deploy-instance:
    runs-on: ubuntu-latest
    if: ${{ inputs.environment != 'prod' || github.ref == 'refs/heads/main' }}
    environment: ${{ inputs.environment }}
    outputs:
      instance_id: ${{ steps.terraform-apply.outputs.instance_id }}
      ip_address: ${{ steps.terraform-apply.outputs.ip_address }}
    steps:
      - name: Checkout Terraform Modules
        uses: actions/checkout@v4
        with:
          repository: nexsware/modules
          path: modules

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.1.2
        with:
          terraform_version: '1.6.0'
          terraform_wrapper: false

      - name: Create Terraform Variables File
        working-directory: ${{ inputs.terraform_dir }}
        run: |
          cat > terraform.tfvars <<EOF
          linode_token = "${{ secrets.LINODE_TOKEN }}"
          region = "${{ inputs.region }}"
          type = "${{ inputs.instance_type }}"
          image = "${{ inputs.image }}"
          label = "${{ inputs.environment }}-${{ inputs.application_name }}"
          root_pass = "${{ secrets.ROOT_PASS }}"
          authorized_keys = [$(if [ -n "${{ secrets.SSH_PUBLIC_KEY }}" ]; then echo '"${{ secrets.SSH_PUBLIC_KEY }}"'; fi)]
          tags = [$(if [ -n "${{ inputs.environment }}" ]; then echo '"${{ inputs.environment }}"'; fi)]
          EOF

      - name: Terraform Init
        working-directory: ${{ inputs.terraform_dir }}
        run: terraform init

      - name: Terraform Apply
        id: terraform-apply
        working-directory: ${{ inputs.terraform_dir }}
        run: |
          terraform apply -auto-approve
          echo "instance_id=$(terraform output -raw id)" >> $GITHUB_OUTPUT
          echo "ip_address=$(terraform output -raw ip_address)" >> $GITHUB_OUTPUT

      - name: Wait for Instance to be Ready
        run: |
          echo "Waiting for instance to boot and SSH to be available..."
          IP_ADDRESS="${{ steps.terraform-apply.outputs.ip_address }}"
          for i in {1..30}; do
            if timeout 5 bash -c "cat < /dev/null > /dev/tcp/$IP_ADDRESS/22" 2>/dev/null; then
              echo "SSH is available on $IP_ADDRESS"
              sleep 10  # Give SSH service time to fully initialize
              break
            fi
            echo "Waiting for SSH... (attempt $i/30)"
            sleep 10
          done

      - name: Verify and Add SSH Key to Server
        if: ${{ secrets.SSH_PUBLIC_KEY }}
        run: |
          IP_ADDRESS="${{ steps.terraform-apply.outputs.ip_address }}"

          # Install sshpass if needed (for password authentication)
          sudo apt-get update && sudo apt-get install -y sshpass

          echo "Verifying SSH key on server..."

          # Try to add the SSH key using root password
          sshpass -p "${{ secrets.ROOT_PASS }}" ssh -o StrictHostKeyChecking=no root@$IP_ADDRESS << 'ENDSSH'
          # Create .ssh directory if it doesn't exist
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Check if the key already exists
          SSH_KEY="${{ secrets.SSH_PUBLIC_KEY }}"
          if ! grep -q "$SSH_KEY" ~/.ssh/authorized_keys 2>/dev/null; then
            echo "Adding SSH public key to authorized_keys..."
            echo "$SSH_KEY" >> ~/.ssh/authorized_keys
            chmod 600 ~/.ssh/authorized_keys
            echo "SSH key added successfully"
          else
            echo "SSH key already exists in authorized_keys"
          fi

          # Display authorized keys for verification
          echo "Current authorized keys:"
          cat ~/.ssh/authorized_keys
          ENDSSH

          echo "SSH key verification complete"